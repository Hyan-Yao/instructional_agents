\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Footer and Navigation Setup
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{date in head/foot}%
    \usebeamerfont{date in head/foot}
    \insertframenumber{} / \inserttotalframenumber
  \end{beamercolorbox}}%
  \vskip0pt%
}

% Turn off navigation symbols
\setbeamertemplate{navigation symbols}{}

% Title Page Information
\title[Academic Template]{Week 6: Data Manipulation with SQL}
\author[J. Smith]{John Smith, Ph.D.}
\institute[University Name]{
  Department of Computer Science\\
  University Name\\
  \vspace{0.3cm}
  Email: email@university.edu\\
  Website: www.university.edu
}
\date{\today}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \frametitle{Introduction to Data Manipulation with SQL}
    \begin{block}{Overview of SQL in Data Manipulation}
        Structured Query Language (SQL) is a standardized programming language designed for managing and manipulating relational databases. 
        It is vital for data analysts, data scientists, and engineers who work with large datasets.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Importance of SQL}
    \begin{itemize}
        \item \textbf{Data Access:} Efficient data retrieval across multiple tables.
        \item \textbf{Data Modification:} Insert, update, and delete records easily.
        \item \textbf{Data Analysis:} Execute complex queries for data aggregation and transformation.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Components of SQL}
    \begin{enumerate}
        \item \textbf{Data Definition Language (DDL):} Manages database structure. 
        \begin{itemize}
            \item Examples: \texttt{CREATE}, \texttt{ALTER}, \texttt{DROP}
        \end{itemize}
        \item \textbf{Data Manipulation Language (DML):} Focuses on data handling.
        \begin{itemize}
            \item Examples: \texttt{SELECT}, \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE}
        \end{itemize}
        \item \textbf{Data Control Language (DCL):} Controls access to data.
        \begin{itemize}
            \item Examples: \texttt{GRANT}, \texttt{REVOKE}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{SQL Command Examples}
    \begin{block}{SELECT Statement}
        \textbf{Purpose:} Retrieve specific data from a database.
        \begin{lstlisting}
        SELECT first_name, last_name FROM employees WHERE department = 'Sales';
        \end{lstlisting}
        This retrieves the first and last names of all employees in the Sales department.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{SQL Command Examples (cont.)}
    \begin{block}{INSERT Statement}
        \textbf{Purpose:} Add new records to a table.
        \begin{lstlisting}
        INSERT INTO employees (first_name, last_name, department) VALUES ('John', 'Doe', 'Sales');
        \end{lstlisting}
    \end{block}
    \begin{block}{UPDATE Statement}
        \textbf{Purpose:} Modify existing records.
        \begin{lstlisting}
        UPDATE employees SET department = 'Marketing' WHERE last_name = 'Doe';
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{SQL Command Examples (cont.)}
    \begin{block}{DELETE Statement}
        \textbf{Purpose:} Remove records from a table.
        \begin{lstlisting}
        DELETE FROM employees WHERE last_name = 'Doe';
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item SQL is essential for effective data manipulation in relational databases.
        \item Mastering SQL commands is crucial for data extraction and analysis.
        \item Understanding SQL streamlines processes in data preparation for mining and machine learning.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Visual Aid}
    \begin{block}{Diagram of SQL Query Structure}
        \begin{itemize}
            \item Include an illustrative flowchart showing the SQL query lifecycle, 
            from entry (inputting SQL commands) to output (result sets returned).
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]{Understanding SQL Queries - Overview}
    \begin{block}{What is SQL?}
        SQL (Structured Query Language) is the standard language used to communicate with relational databases. 
        Understanding the basic structure of SQL queries is essential for manipulating data effectively.
    \end{block}
    \begin{block}{Key Components of SQL Queries}
        The primary components of a SQL query include:
        \begin{itemize}
            \item \textbf{SELECT}
            \item \textbf{FROM}
            \item \textbf{WHERE}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]{Understanding SQL Queries - SELECT, FROM, WHERE}
    \begin{block}{1. SELECT Clause}
        \begin{itemize}
            \item Used to specify the columns to retrieve from the database.
            \item Can include one or more column names or use * to select all columns.
            \item \textbf{Syntax:}
            \begin{lstlisting}[language=SQL]
SELECT column1, column2, ... FROM table_name;
            \end{lstlisting}
            \item \textbf{Example:}
            \begin{lstlisting}[language=SQL]
SELECT first_name, last_name FROM users;
            \end{lstlisting}
        \end{itemize}
    \end{block}
    
    \begin{block}{2. FROM Clause}
        \begin{itemize}
            \item Identifies the tables from which to retrieve data.
            \item Can join multiple tables in this clause.
            \item \textbf{Syntax:}
            \begin{lstlisting}[language=SQL]
SELECT columns FROM table1 JOIN table2 ON condition;
            \end{lstlisting}
            \item \textbf{Example:}
            \begin{lstlisting}[language=SQL]
SELECT title FROM books;
            \end{lstlisting}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]{Understanding SQL Queries - WHERE and Summary}
    \begin{block}{3. WHERE Clause}
        \begin{itemize}
            \item Used to filter records based on specific conditions.
            \item Utilizes logical operators such as =, >, <, AND, and OR.
            \item \textbf{Syntax:}
            \begin{lstlisting}[language=SQL]
SELECT columns FROM table_name WHERE condition;
            \end{lstlisting}
            \item \textbf{Example:}
            \begin{lstlisting}[language=SQL]
SELECT first_name, last_name FROM users WHERE status = 'active';
            \end{lstlisting}
        \end{itemize}
    \end{block}
    
    \begin{block}{Putting It All Together}
        \begin{lstlisting}[language=SQL]
SELECT first_name, last_name 
FROM users 
WHERE status = 'active' AND age > 18;
        \end{lstlisting}
        This query retrieves the first and last names of active users over 18 years old.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of SQL Queries - Overview}
    \begin{block}{Overview}
        SQL (Structured Query Language) is the standard language for managing and manipulating databases. Queries are categorized into several types based on their functionality. 
        In this slide, we will discuss four primary types of SQL queries: \textbf{DDL}, \textbf{DML}, \textbf{DCL}, and \textbf{TCL}.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of SQL Queries - DDL}
    \begin{block}{Data Definition Language (DDL)}
        DDL is used to define and manage all structures in a database. 
        It includes commands for creating, altering, and deleting database objects such as tables, indexes, and schemas.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Key Commands:}
        \begin{itemize}
            \item \texttt{CREATE}: Used to create a new table or database.
            \begin{lstlisting}[language=SQL]
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    HireDate DATE
);
            \end{lstlisting}
            
            \item \texttt{ALTER}: Used to modify an existing database object.
            \begin{lstlisting}[language=SQL]
ALTER TABLE Employees ADD COLUMN Position VARCHAR(50);
            \end{lstlisting}
            
            \item \texttt{DROP}: Deletes an entire table or another database object.
            \begin{lstlisting}[language=SQL]
DROP TABLE Employees;
            \end{lstlisting}
        \end{itemize}
        
        \item \textbf{Key Points:}
        \begin{itemize}
            \item Structure-oriented
            \item No data manipulation involved; focuses on schema and structure
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of SQL Queries - DML, DCL, and TCL}
    
    \begin{block}{Data Manipulation Language (DML)}
        DML is utilized to deal with the manipulation of data stored in a database. 
        It includes commands for inserting, updating, and deleting data.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Key Commands:}
        \begin{itemize}
            \item \texttt{INSERT}: Adds new records to a table.
            \begin{lstlisting}[language=SQL]
INSERT INTO Employees (EmployeeID, FirstName, LastName, HireDate)
VALUES (1, 'John', 'Doe', '2023-01-15');
            \end{lstlisting}
            
            \item \texttt{UPDATE}: Modifies existing records.
            \begin{lstlisting}[language=SQL]
UPDATE Employees 
SET Position = 'Manager' 
WHERE EmployeeID = 1;
            \end{lstlisting}
            
            \item \texttt{DELETE}: Removes records from a table.
            \begin{lstlisting}[language=SQL]
DELETE FROM Employees 
WHERE EmployeeID = 1;
            \end{lstlisting}
        \end{itemize}
        
        \item \textbf{Key Points:}
        \begin{itemize}
            \item Focuses on data manipulation
            \item Includes operational commands to manage data entries
        \end{itemize}
    \end{itemize}
    
    \begin{block}{Data Control Language (DCL)}
        DCL is used to control access to data in the database. 
        It is essential for security management.
    \end{block}

    \begin{itemize}
        \item \textbf{Key Commands:}
        \begin{itemize}
            \item \texttt{GRANT}: Provides user access privileges to database objects.
            \begin{lstlisting}[language=SQL]
GRANT SELECT, INSERT ON Employees TO User1;
            \end{lstlisting}
            \item \texttt{REVOKE}: Removes user access privileges.
            \begin{lstlisting}[language=SQL]
REVOKE INSERT ON Employees FROM User1;
            \end{lstlisting}
        \end{itemize}
        
        \item \textbf{Key Points:}
        \begin{itemize}
            \item Concerned with permission and security
            \item Controls who can access or manipulate data
        \end{itemize}
    \end{itemize}
    
    \begin{block}{Transaction Control Language (TCL)}
        TCL is designed to manage the changes made by DML statements. 
        It allows for transactions to be handled in a cohesive manner, maintaining data integrity.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Key Commands:}
        \begin{itemize}
            \item \texttt{COMMIT}: Saves all changes made during the current transaction.
            \begin{lstlisting}[language=SQL]
COMMIT;
            \end{lstlisting}
            \item \texttt{ROLLBACK}: Undoes changes made during the transaction.
            \begin{lstlisting}[language=SQL]
ROLLBACK;
            \end{lstlisting}
            \item \texttt{SAVEPOINT}: Sets a point in a transaction to which you can later roll back.
            \begin{lstlisting}[language=SQL]
SAVEPOINT savepoint_name;
            \end{lstlisting}
        \end{itemize}
        
        \item \textbf{Key Points:}
        \begin{itemize}
            \item Ensures data integrity during transactions
            \item Important for managing complex operations
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of SQL Queries - Summary}
    \begin{block}{Summary Diagram}
        \begin{itemize}
            \item \textbf{DDL}: Defines database objects (Create, Alter, Drop)
            \item \textbf{DML}: Manipulates data (Insert, Update, Delete)
            \item \textbf{DCL}: Controls access (Grant, Revoke)
            \item \textbf{TCL}: Manages transactions (Commit, Rollback)
        \end{itemize}
    \end{block}
    
    Understanding these types of SQL queries is fundamental for effectively interacting with databases and ensuring data integrity and security. 
    Utilize these commands to strategically manage your data and its structure!
\end{frame}

\begin{frame}[fragile]
    \frametitle{Joins in SQL}
    Joins are essential in SQL as they allow us to combine data from multiple tables based on a related column. 
    They enable powerful data analysis and reporting by integrating data from different sources.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Joins in SQL}
    Here, we will cover four primary types of joins:
    
    \begin{enumerate}
        \item \textbf{INNER JOIN}
        \item \textbf{LEFT JOIN (LEFT OUTER JOIN)}
        \item \textbf{RIGHT JOIN (RIGHT OUTER JOIN)}
        \item \textbf{FULL OUTER JOIN}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN}
    \begin{itemize}
        \item \textbf{Description}: Returns only rows with matching values in both tables.
        \item \textbf{SQL Syntax}:
        \begin{lstlisting}
SELECT columns
FROM table1
INNER JOIN table2
ON table1.common_column = table2.common_column;
        \end{lstlisting}
    \end{itemize}
    \textbf{Example}:
    \begin{lstlisting}
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments
ON employees.department_id = departments.id;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{LEFT JOIN (LEFT OUTER JOIN)}
    \begin{itemize}
        \item \textbf{Description}: Returns all rows from the left table, and matched rows from the right table. NULL for unmatched rows in the right table.
        \item \textbf{SQL Syntax}:
        \begin{lstlisting}
SELECT columns
FROM table1
LEFT JOIN table2
ON table1.common_column = table2.common_column;
        \end{lstlisting}
    \end{itemize}
    \textbf{Example}:
    \begin{lstlisting}
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments
ON employees.department_id = departments.id;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{RIGHT JOIN (RIGHT OUTER JOIN)}
    \begin{itemize}
        \item \textbf{Description}: Returns all rows from the right table, and matched rows from the left table. NULL for unmatched rows in the left table.
        \item \textbf{SQL Syntax}:
        \begin{lstlisting}
SELECT columns
FROM table1
RIGHT JOIN table2
ON table1.common_column = table2.common_column;
        \end{lstlisting}
    \end{itemize}
    \textbf{Example}:
    \begin{lstlisting}
SELECT employees.name, departments.department_name
FROM employees
RIGHT JOIN departments
ON employees.department_id = departments.id;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{FULL OUTER JOIN}
    \begin{itemize}
        \item \textbf{Description}: Combines the results of both left and right joins. Returns all rows from both tables, with NULLs where there are no matches.
        \item \textbf{SQL Syntax}:
        \begin{lstlisting}
SELECT columns
FROM table1
FULL OUTER JOIN table2
ON table1.common_column = table2.common_column;
        \end{lstlisting}
    \end{itemize}
    \textbf{Example}:
    \begin{lstlisting}
SELECT employees.name, departments.department_name
FROM employees
FULL OUTER JOIN departments
ON employees.department_id = departments.id;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points}
    \begin{itemize}
        \item \textbf{Understanding Relationships}: Joins define how tables relate via common columns.
        \item \textbf{Nullable Results}: Different joins can produce NULL values indicating missing match data.
        \item \textbf{Practical Usage}: Choose the type of join based on required data outcomes.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Visual Representation}
    \begin{itemize}
        \item \textbf{Conceptual Diagrams}:
        \begin{itemize}
            \item \textbf{INNER JOIN}: Intersection of two circles.
            \item \textbf{LEFT JOIN}: Entire left circle and intersecting area.
            \item \textbf{RIGHT JOIN}: Entire right circle and intersecting area.
            \item \textbf{FULL OUTER JOIN}: Entire area of both circles.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - Introduction}
    \frametitle{Introduction to Joins in SQL}
    Joins in SQL are used to combine rows from two or more tables based on a related column. 
    Understanding how to use joins effectively allows you to:
    \begin{itemize}
        \item Retrieve comprehensive datasets from multiple tables
        \item Perform effective data analysis
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - Types of Joins}
    \frametitle{Types of Joins}
    \begin{enumerate}
        \item \textbf{INNER JOIN}: Returns rows when there is a match in both tables.
        \item \textbf{LEFT JOIN} (or LEFT OUTER JOIN): 
        Returns all rows from the left table, matched rows from the right; unmatched rows contain NULLs.
        \item \textbf{RIGHT JOIN} (or RIGHT OUTER JOIN): 
        Returns all rows from the right table, matched rows from the left; unmatched rows contain NULLs.
        \item \textbf{FULL OUTER JOIN}: 
        Returns all rows when there is a match in either table, unmatched rows contain NULLs.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - Example Scenario}
    \frametitle{Example Scenario: Customers and Orders}
    Consider two tables:
    
    \textbf{Customers}
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            CustomerID & Name \\
            \hline
            1 & Alice \\
            2 & Bob \\
            3 & Charlie \\
            \hline
        \end{tabular}
    \end{center}
    
    \textbf{Orders}
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            OrderID & CustomerID & Amount \\
            \hline
            101 & 1 & 250 \\
            102 & 1 & 300 \\
            103 & 2 & 150 \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - INNER JOIN Example}
    \frametitle{INNER JOIN Example}
    To retrieve all customers with their corresponding orders:
    
    \begin{block}{SQL Query}
    \begin{lstlisting}[language=SQL]
SELECT Customers.Name, Orders.Amount
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
    \end{lstlisting}
    \end{block}

    \textbf{Result:}
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Name  & Amount \\
            \hline
            Alice & 250    \\
            Alice & 300    \\
            Bob   & 150    \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - LEFT JOIN Example}
    \frametitle{LEFT JOIN Example}
    To get all customers and their orders, including those without orders:
    
    \begin{block}{SQL Query}
    \begin{lstlisting}[language=SQL]
SELECT Customers.Name, Orders.Amount
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
    \end{lstlisting}
    \end{block}

    \textbf{Result:}
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Name    & Amount \\
            \hline
            Alice   & 250    \\
            Alice   & 300    \\
            Bob     & 150    \\
            Charlie & NULL   \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - RIGHT JOIN Example}
    \frametitle{RIGHT JOIN Example}
    To show all orders and their customers, including orders without matching customers:
    
    \begin{block}{SQL Query}
    \begin{lstlisting}[language=SQL]
SELECT Customers.Name, Orders.Amount
FROM Customers
RIGHT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
    \end{lstlisting}
    \end{block}

    \textbf{Result:}
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Name  & Amount \\
            \hline
            Alice & 250    \\
            Alice & 300    \\
            Bob   & 150    \\
            NULL  & NULL   \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - FULL OUTER JOIN Example}
    \frametitle{FULL OUTER JOIN Example}
    To get a complete view of all customers with all orders:
    
    \begin{block}{SQL Query}
    \begin{lstlisting}[language=SQL]
SELECT Customers.Name, Orders.Amount
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
    \end{lstlisting}
    \end{block}

    \textbf{Result:}
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Name    & Amount \\
            \hline
            Alice   & 250    \\
            Alice   & 300    \\
            Bob     & 150    \\
            Charlie & NULL   \\
            NULL    & NULL   \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - Key Points}
    \frametitle{Key Points to Remember}
    \begin{itemize}
        \item Joins are powerful for combining data for comprehensive analysis.
        \item Choose the join type (INNER, LEFT, RIGHT, FULL) based on your query needs.
        \item Correct use of joins simplifies data retrieval in SQL databases.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Using Joins Effectively - Visualization Tip}
    \frametitle{Visualization Tip}
    Consider creating a diagram:
    \begin{itemize}
        \item Visually represent the \textbf{Customers} and \textbf{Orders} tables.
        \item Use arrows to depict relationships formed by joins based on \texttt{CustomerID}.
    \end{itemize}

    \textbf{Practice!} Use different datasets and join types to master SQL joins!
\end{frame}

\begin{frame}[fragile]
    \frametitle{Aggregation Functions in SQL - Introduction}
    \begin{block}{Overview}
        Aggregation functions in SQL allow you to compute a single result from multiple rows of data. 
        Commonly used with the \texttt{GROUP BY} clause, these functions provide a summarized view of the data.
    \end{block}
    \begin{itemize}
        \item \textbf{COUNT}
        \item \textbf{SUM}
        \item \textbf{AVG}
        \item \textbf{MIN}
        \item \textbf{MAX}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Aggregation Functions in SQL - COUNT, SUM, AVG}
    \begin{block}{1. COUNT}
        \begin{itemize}
            \item \textbf{Description}: Counts rows in a dataset or non-null values.
            \item \textbf{Syntax}: \texttt{COUNT(column\_name)}
            \item \textbf{Example}:
            \begin{lstlisting}
SELECT COUNT(employee_id) AS NumberOfEmployees FROM Employees;
            \end{lstlisting}
            \item \textbf{Output}: Total number of employees.
        \end{itemize}
    \end{block}

    \begin{block}{2. SUM}
        \begin{itemize}
            \item \textbf{Description}: Calculates the total sum of a numeric column.
            \item \textbf{Syntax}: \texttt{SUM(column\_name)}
            \item \textbf{Example}:
            \begin{lstlisting}
SELECT SUM(salary) AS TotalSalaries FROM Employees;
            \end{lstlisting}
            \item \textbf{Output}: Total salaries paid to all employees.
        \end{itemize}
    \end{block}

    \begin{block}{3. AVG}
        \begin{itemize}
            \item \textbf{Description}: Computes average of a numeric column.
            \item \textbf{Syntax}: \texttt{AVG(column\_name)}
            \item \textbf{Example}:
            \begin{lstlisting}
SELECT AVG(age) AS AverageAge FROM Employees;
            \end{lstlisting}
            \item \textbf{Output}: Average age of the employees.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Aggregation Functions in SQL - MIN, MAX and Key Points}
    \begin{block}{4. MIN}
        \begin{itemize}
            \item \textbf{Description}: Finds minimum value in a column.
            \item \textbf{Syntax}: \texttt{MIN(column\_name)}
            \item \textbf{Example}:
            \begin{lstlisting}
SELECT MIN(hire_date) AS EarliestHire FROM Employees;
            \end{lstlisting}
            \item \textbf{Output}: The earliest hire date in the Employees table.
        \end{itemize}
    \end{block}

    \begin{block}{5. MAX}
        \begin{itemize}
            \item \textbf{Description}: Identifies maximum value in a column.
            \item \textbf{Syntax}: \texttt{MAX(column\_name)}
            \item \textbf{Example}:
            \begin{lstlisting}
SELECT MAX(salary) AS HighestSalary FROM Employees;
            \end{lstlisting}
            \item \textbf{Output}: The highest salary among all employees.
        \end{itemize}
    \end{block}

    \begin{block}{Key Points}
        \begin{itemize}
            \item Aggregation functions ignore NULL values (except for \texttt{COUNT(*)}).
            \item Commonly used with \texttt{GROUP BY} to summarize data.
            \item Useful in various applications like employee analytics and sales data.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Group By and Having Clauses - Overview}
    \begin{block}{Overview}
        In SQL, the \texttt{GROUP BY} and \texttt{HAVING} clauses are powerful tools for aggregating and filtering data. 
        They allow you to summarize information by grouping rows that share a common attribute 
        and then applying conditions to filter aggregated results.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Group By and Having Clauses - Key Concepts}
    \begin{enumerate}
        \item \textbf{GROUP BY Clause}:
        \begin{itemize}
            \item Groups rows that have the same values in specified columns into summary rows.
            \item Often used with aggregate functions like \texttt{COUNT()}, \texttt{SUM()}, \texttt{AVG()}, etc.
        \end{itemize}
        
        \item \textbf{HAVING Clause}:
        \begin{itemize}
            \item Filters groups created by the \texttt{GROUP BY} clause based on a specified condition.
            \item Unlike \texttt{WHERE}, which filters rows before aggregation, \texttt{HAVING} filters after.
        \end{itemize}
    \end{enumerate}

    \begin{block}{Syntax}
    \begin{lstlisting}[language=SQL]
SELECT column1, aggregate_function(column2)
FROM table_name
WHERE condition
GROUP BY column1;
    \end{lstlisting}
    \end{block}

    \begin{block}{Syntax for HAVING}
    \begin{lstlisting}[language=SQL]
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1
HAVING condition;
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Group By and Having Clauses - Example}
    Consider a \texttt{sales} table with the following fields: \texttt{product_id}, \texttt{salesperson}, and \texttt{amount}.
    
    \begin{lstlisting}
| product_id | salesperson | amount |
|------------|-------------|--------|
| 1          | Alice       | 100    |
| 1          | Bob         | 150    |
| 2          | Alice       | 200    |
| 2          | Bob         | 300    |
| 1          | Alice       | 50     |
    \end{lstlisting}
    
    \textbf{Objective}: Find total sales per salesperson and only include those with total sales greater than $200.

    \begin{block}{SQL Query}
    \begin{lstlisting}[language=SQL]
SELECT salesperson, SUM(amount) AS total_sales
FROM sales
GROUP BY salesperson
HAVING SUM(amount) > 200;
    \end{lstlisting}
    \end{block}

    \textbf{Result}: 
    \begin{lstlisting}
| salesperson | total_sales |
|-------------|-------------|
| Bob         | 450         |
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Subqueries and Nested Queries}
    \frametitle{Understanding Subqueries}
    \begin{block}{Definition}
        A subquery, also known as a nested query, is a query embedded within another SQL query. 
        Subqueries can return single or multiple values and are often used to refine the results of the main query.
    \end{block}
\end{frame}

\begin{frame}[fragile]{Subqueries and Nested Queries - Uses}
    \frametitle{Why Use Subqueries?}
    \begin{itemize}
        \item \textbf{Data Filtering:} Subqueries can simplify complex filter conditions, fetching data based on the results of another query.
        \item \textbf{Modularization:} By using subqueries, you can break down your queries into logical components, making them easier to understand and maintain.
        \item \textbf{Dynamic Analysis:} Subqueries allow for the use of dynamic criteria, where the conditions of the outer query are based on the results from the nested inner query.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Subqueries and Nested Queries - Types}
    \frametitle{Types of Subqueries}
    \begin{enumerate}
        \item \textbf{Single-row Subqueries:} Returns one row and one column.
        \begin{lstlisting}
SELECT employee_name 
FROM employees 
WHERE employee_id = (SELECT manager_id FROM departments WHERE department_name = 'Sales');
        \end{lstlisting}
        \hfill \textit{(Retrieves employee name whose ID matches the Sales department manager's ID.)}
        
        \item \textbf{Multi-row Subqueries:} Returns multiple rows, typically used with operators such as \texttt{IN}, \texttt{ANY}, and \texttt{ALL}.
        \begin{lstlisting}
SELECT employee_name 
FROM employees 
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1400);
        \end{lstlisting}
        \hfill \textit{(Retrieves all employees in departments located at location\_id 1400.)}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Subqueries and Nested Queries - Practical Example}
    \frametitle{Practical Example of Nested Queries}
    \begin{block}{Example Query}
        Imagine you want to find all products that have a price higher than the average price of products in the same category.
        \begin{lstlisting}
SELECT product_name 
FROM products 
WHERE price > (SELECT AVG(price) FROM products WHERE category_id = products.category_id);
        \end{lstlisting}
    \end{block}
    \hfill \textit{(This SQL statement efficiently finds products priced above the average of their category.)}
\end{frame}

\begin{frame}[fragile]{Subqueries and Nested Queries - Key Points}
    \frametitle{Things to Remember}
    \begin{itemize}
        \item \textbf{Enclosure:} Subqueries must be enclosed in parentheses.
        \item \textbf{Restrictions:} \texttt{ORDER BY} and \texttt{GROUP BY} cannot be used directly inside a subquery when itâ€™s used with scalar functions.
        \item \textbf{Placement:} Subqueries can be placed in various parts of a SQL statement: \texttt{SELECT}, \texttt{FROM}, \texttt{WHERE} clauses.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Subqueries and Nested Queries - Conclusion}
    \frametitle{Summary}
    Understanding subqueries and nested queries will empower you to write more sophisticated SQL queries, 
    enhancing your ability to manipulate and analyze data effectively! Focus on:
    \begin{itemize}
        \item \textbf{Efficiency:} Streamlined complex queries.
        \item \textbf{Versatility:} Used in various SQL sections.
        \item \textbf{Performance Implications:} Beware of deeply nested queries; consider using \texttt{JOIN}s when applicable.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Examples of Data Manipulation - Introduction}
    Data manipulation involves altering data within a database through various operations such as selection, insertion, updating, and deletion. SQL (Structured Query Language) provides powerful commands to facilitate these operations.
    
    \begin{itemize}
        \item SQL is essential for querying and manipulating large datasets.
        \item Understanding real-world applications enhances relevance in data processing.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Examples of Data Manipulation - Key SQL Concepts}
    \begin{enumerate}
        \item \textbf{SELECT Statement}:
        \begin{itemize}
            \item Example: \texttt{SELECT employee\_name, salary FROM employees WHERE department = 'Sales';}
        \end{itemize}
        
        \item \textbf{INSERT Statement}:
        \begin{itemize}
            \item Example: \texttt{INSERT INTO employees (employee\_name, salary, department) VALUES ('John Doe', 60000, 'Sales');}
        \end{itemize}
        
        \item \textbf{UPDATE Statement}:
        \begin{itemize}
            \item Example: \texttt{UPDATE employees SET salary = 65000 WHERE employee\_name = 'John Doe';}
        \end{itemize}
        
        \item \textbf{DELETE Statement}:
        \begin{itemize}
            \item Example: \texttt{DELETE FROM employees WHERE employee\_name = 'John Doe';}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Examples of Data Manipulation - Real-World Applications}
    \textbf{1. E-commerce Analytics:}
    \begin{itemize}
        \item Analyzing sales data to improve product availability and pricing.
        \begin{lstlisting}[language=SQL]
SELECT category, SUM(sales_amount) AS total_sales
FROM sales
GROUP BY category;
        \end{lstlisting}
    \end{itemize}

    \textbf{2. Customer Relationship Management (CRM):}
    \begin{itemize}
        \item Tracking customer interactions to enhance service quality.
        \begin{lstlisting}[language=SQL]
SELECT customer_id, COUNT(order_id) AS order_count
FROM orders
GROUP BY customer_id
HAVING order_count > 3;
        \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Examples of Data Manipulation - More Applications}
    \textbf{3. Human Resources Management:}
    \begin{itemize}
        \item Evaluating employee retention by analyzing tenure.
        \begin{lstlisting}[language=SQL]
SELECT employee_name
FROM employees
WHERE DATEDIFF(CURDATE(), hire_date) > 1825;
        \end{lstlisting}
    \end{itemize}

    \textbf{4. Financial Reporting:}
    \begin{itemize}
        \item Preparing financial statements from transactional data.
        \begin{lstlisting}[language=SQL]
SELECT p.product_name, SUM(s.amount) AS total_revenue
FROM products p
JOIN sales s ON p.product_id = s.product_id
GROUP BY p.product_name;
        \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Examples of Data Manipulation - Key Points and Conclusion}
    \begin{block}{Key Points}
        \begin{itemize}
            \item SQL is essential for querying and manipulating large datasets.
            \item Writing effective SQL queries leads to better data insights.
            \item Real-world applications showcase SQL's versatility.
        \end{itemize}
    \end{block}

    \textbf{Conclusion:} Data manipulation with SQL is a critical skill for data professionals. Mastering SQL queries enables significant contributions to data-driven decision-making processes.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common Errors in SQL - Introduction}
    SQL (Structured Query Language) allows us to interact seamlessly with databases, but errors can occur when writing queries. This slide highlights common mistakes and troubleshooting techniques to help you write effective SQL queries.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common SQL Errors}
    \begin{enumerate}
        \item \textbf{Syntax Errors}
            \begin{itemize}
                \item \textbf{Description:} Occur when SQL statements are incorrectly structured.
                \item \textbf{Example:}
                \begin{lstlisting}
                SELECT name FROM students WHERE age > 18 
                -- Missing semicolon can cause an error in some SQL environments.
                \end{lstlisting}
            \end{itemize}
        
        \item \textbf{Logical Errors}
            \begin{itemize}
                \item \textbf{Description:} Queries run without syntax errors but yield unexpected results due to incorrect logic.
                \item \textbf{Example:}
                \begin{lstlisting}
                SELECT * FROM orders WHERE order_date = '2022-01-01';
                -- If you meant to fetch orders from January but wrote an exact date, logical error occurs.
                \end{lstlisting}
            \end{itemize}
        
        \item \textbf{Type Mismatch Errors}
            \begin{itemize}
                \item \textbf{Description:} Occurs when values in queries do not match the expected data type.
                \item \textbf{Example:}
                \begin{lstlisting}
                SELECT * FROM products WHERE price < 'ten'; 
                -- 'ten' should be a numeric type, not a string.
                \end{lstlisting}
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common SQL Errors (cont.)}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item \textbf{Ambiguous Column References}
            \begin{itemize}
                \item \textbf{Description:} When querying multiple tables, specifying which table a column belongs to can prevent confusion.
                \item \textbf{Example:}
                \begin{lstlisting}
                SELECT name FROM employees, departments WHERE employees.dept_id = departments.id;
                -- Use table names to clarify: employees.name instead.
                \end{lstlisting}
            \end{itemize}

        \item \textbf{Missing WHERE Clauses}
            \begin{itemize}
                \item \textbf{Description:} Fails to restrict results, resulting in larger datasets than intended.
                \item \textbf{Example:} 
                \begin{lstlisting}
                SELECT * FROM customers; 
                -- Will return all customers instead of a specific subset.
                \end{lstlisting}
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Troubleshooting Techniques}
    \begin{itemize}
        \item \textbf{Review Query Syntax:} Always double-check SQL syntax using SQL documentation or an IDE with query highlighting.
        \item \textbf{Use Commenting:} Break down complex queries using comments to isolate sections:
        \begin{lstlisting}
        -- Fetching active users
        SELECT * FROM users WHERE status = 'active'; 
        \end{lstlisting}
        \item \textbf{Test with Sample Data:} Run queries on a small dataset to verify results before applying them to the entire database.
        \item \textbf{Error Messages:} Pay careful attention to error messages; they often indicate which line of the SQL query caused the issue.
        \item \textbf{Database Tools:} Utilize built-in database tools (like \texttt{EXPLAIN} in PostgreSQL) to analyze query performance and identify potential issues.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Remember}
    \begin{itemize}
        \item \textbf{Always Use Semicolons:} End SQL queries with a semicolon in environments that require it.
        \item \textbf{Clear Logic is Key:} Think through the logic of your queries to avoid unexpected results.
        \item \textbf{Stay Consistent with Data Types:} Ensure that all data types align with those defined in your database schema to avoid mismatches.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Summary}
    By understanding these common errors and employing effective troubleshooting techniques, you will become more proficient in writing accurate SQL queries, leading to better data management and analysis.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Best Practices for SQL Query Optimization}
    \begin{block}{Understanding SQL Query Optimization}
        SQL query optimization involves writing queries that execute efficiently, especially crucial when dealing with large datasets. By optimizing SQL queries, we can reduce execution time, decrease server load, and improve overall database performance.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Best Practices for SQL Query Optimization - Part 1}
    \begin{enumerate}
        \item \textbf{Use SELECT Statements Wisely}
        \begin{itemize}
            \item Only Query Required Columns:
            \begin{lstlisting}
SELECT name, email FROM users;
            \end{lstlisting}
            \item Avoiding SELECT DISTINCT: Use it only when necessary to limit overhead.
        \end{itemize}
        
        \item \textbf{Leverage Indexes}
        \begin{itemize}
            \item Create Indexes on Frequently Queried Columns:
            \begin{lstlisting}
CREATE INDEX idx_user_email ON users(email);
            \end{lstlisting}
            \item Understand the Impact: Indexes speed up reads but can slow down writes.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Best Practices for SQL Query Optimization - Part 2}
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{Optimize Joins}
        \begin{itemize}
            \item Use INNER JOIN Instead of OUTER JOIN When Possible:
            \begin{lstlisting}
SELECT u.name, o.order_date 
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id;
            \end{lstlisting}
            \item Joining on Indexed Columns is recommended for better performance.
        \end{itemize}
        
        \item \textbf{Mind the WHERE Clause}
        \begin{itemize}
            \item Filter Early: Use WHERE clauses to minimize the processed rows.
            \begin{lstlisting}
SELECT * FROM orders WHERE order_date >= '2023-01-01';
            \end{lstlisting}
            \item Use Efficient Comparison Operators: Prefer equality comparisons over LIKE.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Best Practices for SQL Query Optimization - Part 3}
    \begin{enumerate}
        \setcounter{enumi}{4}
        \item \textbf{Consider Database Functions and Operations}
        \begin{itemize}
            \item Use Built-in Functions to streamline data manipulation (e.g., COUNT(), SUM()).
        \end{itemize}
        
        \item \textbf{Monitor Query Performance}
        \begin{itemize}
            \item Analyze Execution Plans:
            \begin{lstlisting}
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';
            \end{lstlisting}
            \item Regularly Review Query Execution Time for optimization.
        \end{itemize}
    \end{enumerate}
    
    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item Efficiency Matters: Well-structured queries lead to faster data retrieval.
            \item Test and Adapt: Validate performance before and after optimization.
            \item Learning Continues: Stay updated on SQL best practices for ongoing optimization.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion: Mastering SQL Query Optimization}
    By implementing these best practices for SQL query optimization, you can significantly enhance the performance of your data manipulation tasks, making your applications more efficient and responsive.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion: Mastering SQL for Data Manipulation - Key Points}
    \begin{itemize}
        \item \textbf{Fundamentals of SQL}
            \begin{itemize}
                \item SQL (Structured Query Language) is essential for data manipulation in relational databases.
                \item Key commands include:
                    \begin{itemize}
                        \item \textbf{SELECT}: Retrieve data
                        \item \textbf{INSERT}: Add new data
                        \item \textbf{UPDATE}: Modify existing data
                        \item \textbf{DELETE}: Remove data
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{Importance of SQL in Data Science}
            \begin{itemize}
                \item Enables efficient interaction with data.
                \item Facilitates extraction of actionable insights for data-driven decisions.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion: Mastering SQL for Data Manipulation - Applications}
    \begin{itemize}
        \item \textbf{Practical Applications}
            \begin{itemize}
                \item \textbf{Business Analytics}: Analyzing sales data to identify trends.
                    \begin{block}{Example}
                        \begin{lstlisting}[language=SQL, backgroundcolor=lightgray]
SELECT product, sales 
FROM sales_data 
WHERE month = 'March';
                        \end{lstlisting}
                    \end{block}
                
                \item \textbf{Healthcare}: Managing patient records and optimizing resources.
                
                \item \textbf{Marketing}: Targeting customer segments through behavior analysis.
            \end{itemize}
        
        \item \textbf{Best Practices to Master SQL}
            \begin{itemize}
                \item Write efficient queries for large datasets.
                \item Use specific columns; avoid \textbf{SELECT *}.
                \item Utilize indexes to speed up data retrieval.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion: Mastering SQL for Data Manipulation - Final Thoughts}
    \begin{itemize}
        \item \textbf{SQL vs Other Tools}
            \begin{itemize}
                \item Complements Python (Pandas), R, and other tools.
                \item Often used for initial data extraction prior to deeper analysis.
            \end{itemize}
        
        \item \textbf{Conclusion}
            \begin{itemize}
                \item Mastering SQL is vital for careers in data science.
                \item Transforms raw data into meaningful insights that drive strategies.
            \end{itemize}
        
        \item \textbf{Call to Action}
            \begin{itemize}
                \item Challenge yourself to write 3 complex SQL queries this week.
                \item Engage in discussion and troubleshooting in our next session!
            \end{itemize}
    \end{itemize}
\end{frame}


\end{document}